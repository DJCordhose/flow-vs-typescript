<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Type Systems for JavaScript</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">-->
    <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">-->


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
        .todo:before {
            content: 'TODO: ';
        }
        .todo {
            color: red !important;
        }
        code span.line-number {
            color: lightcoral;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<!--https://www.jfokus.se/jfokus/talks.jsp#TypedJavaScriptwithT-->
<!--10:10 - 11:00-->

<!--JavaScript is the natural choice when developing for the browser.-->
<!--For larger projects, however, there are issues concerning type safety and refactoring.-->
<!--TypeScript, Flow, and Elm are different approaches to compensate for that shortcoming by-->
<!--each introducing a type system of their own.-->

<!--Flow is a static type checker that has been developed and used by Facebook to find errors in JavaScript.-->

<!--TypeScript is an extension to JavaScript that compiles back to ES5 or ES6.-->
<!--It is actively developed by Microsoft and used as primary language for Googleâ€™s Angular 2 framework.-->

<!--Elm is the most radical approach, which abstracts quite a bit from JavaScript.-->

<!--Based on a set of real world examples that can benefit from type annotations we will discuss how-->
<!--the three approaches compare to each other.-->

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

        <section>
            <h1>Type Systems for JavaScript</h1>
            <h2><span class="elm">Elm, </span>Flow, and TypeScript</h2>
            <p><a href="https://www.jfokus.se/jfokus/talks.jsp#TypedJavaScriptwithT" target="_blank">
                Jfokus 2017, Stockholm, Sweden
            </a></p>

            <p>Slides for this talk: <a href="http://bit.ly/types-jfokus">
                http://bit.ly/types-jfokus
            </a></p>
            <p>
                <small><a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
                </small>
            </p>
            <p>Extended Version (constantly updated): <a href="http://bit.ly/js-types">
                http://bit.ly/js-types
            </a></p>
        </section>

        <section>
            <h2>Disclaimer</h2>
            <p>I am a practitioner, using both TypeScript and Flow in my projects</p>
            <p>I am no type theory expert</p>
            <p>I have not used Elm in any real world project, yet</p>
        </section>

        <section>
            <h3>Not a single cat image in this talk</h3>
            <h4 class="fragment">Even worse: not even any image</h4>
            <div class="fragment" >
                <p>My compensation to make this a valid talk</p>
                <img src="cat.jpg" height="400">
                <br>
                <small><a href="https://twitter.com/Creatuluw/status/749151998415634432">https://twitter.com/Creatuluw/status/749151998415634432</a></small>
            </div>

        </section>

        <section>
            <h2>Why using type systems?</h2>
            <div class="fragment">
                <h3>type systems make code easier to maintain</h3>
                <p >type annotations / inferred types</p>
                <ul >
                    <li>can make code more readable
                    <li>can make code easier to analyse
                    <li>can allow for reliable refactoring
                    <li>can allow for generally better IDE support
                    <li>can catch some (type related) errors early
                </ul>
            </div>
            <p class="fragment"><a href="https://channel9.msdn.com/Events/Build/2016/B881" target="_blank">
                Anders Hejlsberg@Build2016: <em>Big JavaScript codebases tend to become "read-only".</em>
            </a></p>
        </section>

        <section>
            <h2>TypeScript</h2>
            <h3 class="fragment">ease of use and tool support over soundness</h3>
            <ul class="fragment">
                <li><a target="_blank" href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
                <li>By Microsoft (Anders Hejlsberg)
                <li>Based on ES6 (probably ES7/ES8)
                <li>Adds optional type annotations, visibility, and decorators
                <li>Compiler checks and removes annotations
                <li>2.x with major changes released recently
                <!--<li><a target="_blank" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript">Latest 1.8 release adds more general sane checks</a>-->
                <!--<li>External declarations can add type information to pure JavaScript-->
                <!--<li>Extensive support in-->

                <!--<a target="_blank" href="https://youtu.be/uceWBKISaF8">WebStorm</a> and Visual Studio Code-->
            </ul>
            <p class="fragment"><strong>We restrict ourselves to version 2 here</strong></p>
        </section>

        <section>
            <h2>Flow</h2>
            <h3 class="fragment">soundness, no runtime exceptions as goal</h3>
            <ul class="fragment">
                <li><a target="_blank" href="http://flowtype.org/">http://flowtype.org/</a>
                <li>By Facebook
                <li><em>Flow is a static type checker, designed to quickly find errors in JavaScript applications</em>
                <li>Not a compiler, but checker
                <!--<li>Works without any type annotations-->
                <!--<li>Very good at inferring types-->
                <li>If present, type annotations can very easily be removed by babel for runtime
            </ul>
        </section>

        <section class="elm">
            <h2>Elm</h2>
            <h3 class="fragment">simplicity, soundness, no runtime exceptions</h3>
            <ul class="fragment">
                <li><a target="_blank" href="http://elm-lang.org/">http://elm-lang.org/</a>
                <li>Language of its own
                <li>functional, not object-oriented
                <li>no null, no mutation
                <li>Geared towards Web Applications
                <li>Compiler creates JavaScript
            </ul>
        </section>

        <!--<section>-->
            <!--<h2>Basics</h2>-->
        <!--</section>-->

        <section>
            <h2>Demo</h2>
            <h3>Some basic TypeScript 2.2 hacking in Visual Studio Code 1.10</h3>
        </section>

        <section>
        <h3>TypeScript (similar to what we just hacked)</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>let foo: string;
// variables can have type information
let foo: string;
foo = 'yo';
// Error: Type 'number' is not assignable to type 'string'.
foo = 10;
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>

// types can be inferred (return type)
function sayIt(what: string) {
    return `Saying: ${what}`;
}
const said: string = sayIt(obj);

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
    what: string; // mandatory

    constructor(what: string) {
        this.what = what;
    }

    // return type if you want to
    sayIt(): string {
        return `Saying: ${this.what}`;
    }
}
</code></pre>
      </section>

        <section>
        <h3>Flow</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// variables can have type information
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// types can be explicit (parameter) or inferred (return type)
function sayIt(what: string) {
    return `Saying: ${what}`;
}
const said: string = sayIt(obj);

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
    what: string; // type also mandatory

    constructor(what: string) {
        this.what = what;
    }

    // return type if you want to
    sayIt(): string {
        return `Saying: ${this.what}`;
    }
}

</code></pre>
      </section>

        <section>
            <h2>Flow and TypeScript basics are pretty similar</h2>
            <p>Those basic features help with documentation, refactoring, and IDE support</p>
        </section>

        <section class="elm">
            <h3>Elm: a totally different story</h3>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
let
    -- declaration using type
    foo : String
    foo = "yo"
    -- Error: everthing is const, can not re-assign
    foo = "yo yo"

    foo2 : String
    -- Error: `The definition of `obj2` does not match its type annotation.`
    foo2 = 10
</code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
let
    -- type annotations are optional, can be inferred
    sayIt : String -> String
    sayIt what =
        "Saying: " ++ what

    said : String
    said = sayIt obj
</code></pre>
            <p class="fragment">No classes and methods in elm</p>
        </section>

        <section>
            <h3>Structural Typing for both TypeScript and Flow</h3>
            <pre><code class="typescript line-numbers" contenteditable data-trim data-leftpad>
class Dog {
  name: string;
  woof() {...}
}

interface NamedObject {
    name: string;
}
// this is fine class does not need to explicitly implement it
let namedObject: NamedObject = dog;
            </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="11">
// same thing, also fine
let namedObject: NamedObject = {
    name: "Olli"
};

// not fine in either, missing name
let namedObject: NamedObject = {
    firstName: "Olli"
};
            </code></pre>
        </section>

        <section>
            <h2>Structural vs Nominal Typing</h2>
            <ul>
                <li class="fragment">Nominal Typing: types are compatible when their declared types match
                <li class="fragment">Structural Typing: types are compatible when their structures match
                <li class="fragment">Java, C#, C++, C all use nominal typing exclusively
                <li class="fragment">Flow classes are also treated as nominal types
                <li class="fragment">TypeScript classes are treated as structural types
                <li class="fragment">Everything else in both Flow and TypeScript uses structural typing
                <li class="fragment elm">Elm always uses structural typing with exact matches on Records
            </ul>
        </section>

        <section>
            <h2>Nullability</h2>
            <p>One of my main sources of runtime exceptions when programming Java</p>
            <p><small>Even after many years it is still surprising how many corner cases I miss in complex code</small></p>
        </section>

        <section class="flow">
            <h3>Flow</h3>
            <div class="fragment">
                <p>what is the result here in pure JavaScript?</p>
                <pre><code class="typescript line-numbers" contenteditable data-trim>
function foo(num) {
    if (num > 10) {
        return 'cool';
    }
}
console.log(foo(9).toString());
</code></pre>

            </div>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
"Uncaught TypeError: Cannot read property 'toString' of undefined"
</code></pre>
            <div class="fragment">
                <p>What the flow checker thinks about this</p>
                <pre><code class="typescript line-numbers" contenteditable data-trim>
// error: call of method `toString`.
// Method cannot be called on possibly null value
console.log(foo(9).toString());
</code></pre>
            </div>
            <div class="fragment">
            <p>To fix this, we need to check the result</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
const fooed = foo(9);
if (fooed) {
    fooed.toString();
}
</code></pre>
            </div>
            <p class="fragment">Types are non-nullable by default in flow</p>
        </section>

        <section class="typescript">
            <h3>TypeScript</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// both TypeScript and flow allow
// to put the type annotation here instead of using inference
function foo(num: number) {
    if (num > 10) {
        return 'cool';
    }
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// same as flow
const fooed: string|void = foo(9);
if (fooed) {
    fooed.toString();
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// or tell the compiler we know better (in this case we actually do)
fooed!.toString();
</code></pre>
            <div class="fragment">
                <p>Only applies to TypeScript 2.x</p>
                <p>Only works when <em>strictNullChecks</em> option is checked</p>
                <p>All types nullable by default in TypeScript 1.x</p>
            </div>
        </section>

        <section class="elm">
            <h3>Elm</h3>
            <p class="fragment">There neither is <code>null</code> nor <code>undefined</code> in elm</p>
            <p class="fragment">Rather
                <a target="_blank" href="https://guide.elm-lang.org/error_handling/maybe.html">Maybe</a> plus pattern matching</p>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
-- Maybe is predefined
-- http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe
type Maybe a = Nothing | Just a
</code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
foo : Int -> Maybe String
foo num =
    if num > 10 then
        Just "cool"
    else
        Nothing
</code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
-- pattern matching (need to match all cases)
case (foo 11) of
    Just message -> message
    Nothing -> ""
</code></pre>
        </section>

        <section>
            <h3>Generic Type information</h3>
            <p class="fragment">Types can be parameterized by others</p>
            <p class="fragment">Most common with collection types</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// nope, no cat
cats.push(10);
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="5">
// nope, no cat
cats.push(new Animal('Fido'));
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="7">
// cool, is a cat
cats.push(new Cat('Purry'));
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="9">
// cool, cat is a sub type of animal
animals.push(new Cat('Purry'));
           </code></pre>
        </section>

        <section>
            <h3>Up to this point this pretty much works in Flow and TypeScript the same way ...</h3>
        </section>

        <section>
            <h3>... but wait</h3>
        </section>

        <section>
        <h3>TypeScript</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// error TS2322: Type 'Animal[]' is not assignable to type 'Cat[]'.
//  Type 'Animal' is not assignable to type 'Cat'.
//    Property 'purrFactor' is missing in type 'Animal'.
cats = animals;
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="7">
// wow, works, but is no longer safe
animals = cats;
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim  data-num-start="9">
// because those are now all cool
animals.push(new Dog('Brutus'));
animals.push(new Animal('Twinky'));
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim  data-num-start="12">
// ouch:
cats.forEach(cat => console.log(`Cat: ${cat.name}`));
// Cat: Purry
// Cat: Brutus
// Cat: Twinky
</code></pre>
            <p class="fragment">TypeScript allows for birds and dogs to be cats here :)</p>
      </section>

        <section>
        <h3>Flow</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// ERROR
// property `purrFactor` of Cat. Property not found in Animal
cats = animals;
           </code></pre>
           <pre class="fragment"><code class="typescript  line-numbers" contenteditable data-trim data-num-start="6">
// same ERROR
animals = cats;
           </code></pre>
            <p class="fragment">Flow does not have have this caveat</p>
      </section>

        <section>
            <h2>The flipside</h2>
            <p>This code is safe (as we access cats in a readonly fashion)</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
function logAnimals(animals: Array&lt;Animal>) {
    animals.forEach(animal => console.log(`Animal: ${animal.name}`));
}

logAnimals(cats);
</code></pre>
            <ul  class="fragment">
                <li>This works in TypeScript (and it should)</li>
                <li>however, potentially not safe, there is nothing to keep us from writing to cats</li>
                <li>Flow does not allow this, even though it is safe</li>
            </ul>
            <div class="fragment">

            <p>much despised Java generics excel here as they can actually make that code safe (another difference:
                <a target="_blank" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Comparing_declaration-site_and_use-site_annotations">
                    Use-site variance
                </a>)
            </p>
            <pre><code class="java line-numbers" contenteditable data-trim>
// Java
void logAnimals(List&lt;? extends Animal> animals) {
    animals.forEach(animal -> System.out.println("Animal: " + animal.name));
    // illegal:
    animals.add(new Animal("Twinky"));
}
</code></pre>
            </div>

        </section>

        <section>
            <h3>Some Type Inference Magic</h3>
            <p>Consider</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
class Dog { woof() { } }

const animals = [];
animals.push(new Dog());
</code></pre>
            <div class="fragment">
                <p>both TypeScript and Flow know this is safe, as we have only added Dogs so far</p>
                <pre><code class="typescript line-numbers" contenteditable data-trim data-num-start="5">
animals.forEach((animal: Dog) => animal.woof());
</code></pre>

            </div>
            <div class="fragment">
                <p>Adding Cats <em>later</em> and thus changing array type later</p>
                <pre><code class="typescript line-numbers" contenteditable data-trim>
class Cat { meow() { } }
animals.push(new Cat());
</code></pre>
                <p>does not affect TypeScript (correct), but makes Flow fail</p>

            </div>
        </section>

        <section class="elm">
            <h3>Elm</h3>
            <p class="fragment">does not have classes or subtypes</p>
            <p class="fragment">has Records (like JavaScript Objects) and generic data structures (e.g. List)</p>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim data-leftpad>
type alias Animal = { name : String }
someAnimal1 = { name = "Patrick"}

animals : List Animal -- generic data structure
animals = [ someAnimal1, someAnimal2, ... ]
           </code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim data-leftpad data-num-start="4">
type alias Cat = { name : String, coatColor : String }

cats : List Cat
cats = [ someCat1, someCat2, ... ]

           </code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
-- sure
moreAnimals : List Animal
moreAnimals = animals

-- Error: Looks like a record is missing the `coatColor` field.
evenMoreAnimals : List Animal
evenMoreAnimals = cats

-- nope, same problem
moreCats : List Cat
moreCats = animals
           </code></pre>
        </section>

        <section>
            <h3>Differences in Generic Types</h3>
            <ul>
                <li class="fragment">TypeScript
                    <ul>
                        <li><a target="_blank" href="https://twitter.com/ahejlsberg/status/822882400724131841?s=03">always covariant</a> (more special):<br>
                            parametric types are compatible if the type to assign from has a more special type parameter</li>
                        <li>seems most intuitive, allows for obviously wrong code, though
                    </ul>
                </li>
                <li class="fragment">Flow
                    <ul>
                        <li>
                            <a href="https://flowtype.org/docs/classes.html#polymorphism-and-type-parameter-variance"
                            target="_blank">
                                using generic types you can choose from invariant (exact match), covariant <em>+</em> (more special), and contravariant <em>-</em> (more common)</a></li>
                        <li>Array in Flow has an invariant parametric type
                        <li>more expressive, harder to master, disallows some correct code
                    </ul>
                </li>
                <li class="fragment elm">Elm
                    <ul>
                        <li>Generic data structures using type variables
                        <li>all types have to match exactly
                    </ul>
            </ul>
            <!--<p class="fragment">Both Flow and TypeScript support upper, but not lower bounds</p>-->
        </section>

        <!--<section>-->
            <!--<h3>Bounds in Generics</h3>-->
            <!--<p>Both Flow and TypeScript support upper, not lower bounds</p>-->
            <!--<p>Both Flow and TypeScript support-->
                <!--<a target="_blank" href="https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification">-->
                    <!--F-Bounded Polymorphism-->
                <!--</a>-->
            <!--</p>-->
            <!--<p><a target="_blank" href="https://flowtype.org/blog/2015/03/12/Bounded-Polymorphism.html">https://flowtype.org/blog/2015/03/12/Bounded-Polymorphism.html</a></p>-->
            <!--<p><a target="_blank" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#type-parameters-as-constraints">https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#type-parameters-as-constraints</a></p>-->
        <!--</section>-->

        <section class="elm">
            <h3>Mutation, const</h3>
            <p class="fragment"><strong>TypeScript and flow</strong>: same as JavaScript (const optional, immutable via lib)</p>
            <p class="fragment"><strong>TypeScript</strong>: readonly for properties</p>
            <p class="fragment"><strong>Elm</strong>: everything always immutable and const</p>
        </section>

        <section class="elm">
            <h3>`Changing` records in Elm</h3>
            <p class="fragment">Central Question: If everything always immutable and const, how do you make modifications?</p>
            <p class="fragment">Answer:</p>
            <ul class="fragment">
                <li>you do not really make mutations
                <li>instead create a new record
                <li>taking over some of the properties of the old record and
                <li>setting some new properties
            </ul>
            <div>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
type alias Cat = { name : String, coatColor : String, age: Int}
someCat = { name = "Purry", age = 2, coatColor = "gray"}
</code></pre>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
haveBirthday : Cat -> Cat
haveBirthday cat =
  -- make a copy, but with changed age
  { cat | age = cat.age + 1 }
</code></pre>
                <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="6">
agedCat : Cat
agedCat = haveBirthday someCat
</code></pre>
            </div>
        </section>

        <section>
            <h3>`any` type</h3>
            <p class="fragment">can be anything, not specified</p>
            <p class="fragment">can selectively disable type checking</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function func(a: any) {
    return a + 5;
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// cool
let r1: string = func(10);

// cool
let r2: boolean = func('wat');
</code></pre>

            <ul>
                <li class="fragment"><em>flow / TypeScript 2</em>: explicit any supported, but any never inferred
                <li class="fragment elm"><em>Elm</em>: does not exist, everything has exact type
            </ul>
        </section>

        <section>
            <h2>Union Types</h2>
            <p class="fragment">aka Disjoint Unions aka Tagged Unions aka Algebraic data types</p>
            <p class="fragment">to describe data with weird shapes</p>
            <p class="fragment">depending on some data other data might apply or not</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
 // a disjoint union type with two cases
type Response = Result | Failure;

type Result = { status: 'done', payload: Object }; // all good, we have the data
type Failure = { status: 'error', code: number}; // error, we get the error code
           </code></pre>
        </section>

        <section>
            <h3>Implementation both in Flow and TypeScript</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function callback(response: Response) {
    // works, as this is present in both
    console.log(response.status);
    // does not work,
    // as we do not know if it exists, just yet
    console.log(response.payload); // ERROR
    console.log(response.code); // ERROR
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-num-start="7">    switch (response.status) {
        case 'done':
            // this is the special thing:
            // type system now knows, this is a Result
            console.log(response.payload);
            break;
        case 'error':
            // and this is a Failure
            console.log(response.code);
            break;
    }
}           </code></pre>
        </section>

        <section class="elm">
            <h3>Elm</h3>
            <p class="fragment">simple and concise union types</p>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim data-leftpad>
type Response = Result String | Failure Int
</code></pre>
            <p class="fragment">switching over union type alternatives using pattern matching</p>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim data-num-start="3" data-leftpad>
callback : Response -> String
callback response =
    -- pattern matching
    case response of
        Result payload -> payload
        Failure code ->
                if code >= 400 && code < 500 then "you messed up"
                else "we messed up"
</code></pre>
            <p class="fragment">usage</p>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim data-num-start="10" >
callback (Result "response")
-- response

callback (Failure 404)
-- you messed up
            </code></pre>
        </section>

        <!--<section>-->
            <!--<h2>Integration with raw JavaScript</h2>-->
        <!--</section>-->

        <!--<section>-->
            <!--<h3>3rd Party Libraries in Flow</h3>-->
            <!--<ul>-->
                <!--<li>Core Declarations come with Flow Checker, includes React-->
                <!--<li>Other external declarations are optional-->
                <!--<li><a target="_blank"-->
                       <!--href="https://github.com/flowtype/flow-typed">-->
                    <!--External Flow Type Definitions-->
                <!--</a>-->
                <!--<li>some libraries even come with added flow type declarations (e.g. immutable.js)-->
                <!--<li><a target="_blank"-->
                       <!--href="https://flowtype.org/docs/third-party.html">-->
                    <!--Declarations can be added to flow config files-->
                <!--</a>-->
                <!--<li>If there are no existing declaration files: still works, but less powerful-->
            <!--</ul>-->
        <!--</section>-->

        <!--<section>-->
            <!--<h3>TypeScript Declaration files</h3>-->
            <!--<ul>-->
                <!--<li>Much larger base for external declarations <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank">DefinitelyTyped</a>-->
                <!--<li>TypeScript 1.x-->
                <!--<ul>-->
                    <!--<li>needed External Type Declarations for 3rd party libraries</li>-->
                    <!--<li>turned out to be a major PITA</li>-->
                <!--</ul>-->
                <!--</li>-->
                <!--<li>TypeScript 2.x-->
                    <!--<ul>-->
                        <!--<li>like Flow</li>-->
                        <!--<li>install external type declarations transparently <a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/" target="_blank">using npm</a>-->
                            <!--(e.g.<em>npm install @types/react &#45;&#45;save</em>)-->
                    <!--</ul>-->
                <!--</li>-->
            <!--</ul>-->
        <!--</section>-->

        <!--<section class="elm">-->
            <!--<h3>Using JavaScript Code in Elm</h3>-->
            <!--<ul>-->
                <!--<li>in practice, most production Elm projects end up wanting to access the JS ecosystem-->
                <!--<li>integration works via messages through ports (<a target="_blank"-->
                       <!--href="https://guide.elm-lang.org/interop/javascript.html">-->
                <!--https://guide.elm-lang.org/interop/javascript.html-->
                <!--</a>)-->
                <!--<li>Only part of the app where there can still be runtime exceptions-->
                <!--<li>data from JavaScript sent like JSON-->
                <!--<li>needs to be converted and typed in Elm-->
            <!--</ul>-->
        <!--</section>-->

        <!--<section>-->
            <!--<h3 style="top: -30px; position: relative">Should you use a type checker?</h3>-->
            <!--<ul class="fragment" style="top: -30px; position: relative">-->
                <!--<li>don't be fooled: checkers do not make your programs error free-->
                <!--<li><a target="_blank" href="http://danluu.com/empirical-pl/">there seems to be little or no impact on productivity</a>-->
                <!--<li>initial effort to introduce a checker is low, though-->
                <!--<li>but a type system is a complex thing, it comes at a cost (of getting understanding and getting types right)-->
            <!--</ul>-->
            <!--<p class="fragment" style="top: -30px; position: relative">My recommendation</p>-->
            <!--<ul class="fragment" style="top: -40px; position: relative">-->
                <!--<li >if your project does not live for long: <em >no</em>-->
                <!--<li >if your project is really simple: <em >no</em>-->
                <!--<li >if there is a chance you will need to refactor the thing: <em >yes</em>-->
                <!--<li >if your system is very important or even crucial for the success of your company: <em >yes</em>-->
                <!--<li >if people enter or leave your team frequently: <em >yes</em>-->
                <!--<li >you have substantial amount of algorithmic code: <em >yes</em>-->
            <!--</ul>-->
        <!--</section>-->

        <section>
            <h2>Where do they excel?</h2>
            <ul>
                <li class="fragment">TypeScript: <em>supporting people from Java and C# land</em>
                    <ul>
                        <li>more complete IDE support
                        <li>language server
                        <li>large set of 3rd party declaration files
                    </ul>
                </li>
                <li class="fragment">Flow: <em>providing typings for idiomatic JavaScript</em>
                    <ul>
                        <li>easy to get started even with existing project
                        <li>more powerful and flexible generics
                        <li>nominal typing for classes
                    </ul>
                </li>
                <li class="fragment elm">Elm: <em>functional language deliberately different from JavaScript</em>
                    <ul>
                        <li>simplicity of type system (no JavaScript legacy)
                        <li>always completely typed (no any)
                        <li>everything immutable and constant always and everywhere
                        <li>complete package (also great orientation for beginners)
                    </ul>
                </li>
            </ul>
        </section>

        <section>
            <h3>Special thanks for giving feedback and helping with this presentation</h3>
            <ul>
                <li>Daniel Rosenwasser: @drosenwasser (from the TypeScript team)</li>
                <li>Avik Chaudhuri: @__avik (from the Flow team)</li>
                <li>Richard Feldman: @rtfeldman and Evan Czaplicki: @czaplic (Elm people)</li>
            </ul>
        </section>

        <section>
            <h1>Thank you!</h1>

            <h2>Questions / Discussion</h2>

            <p>
                <a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
            </p>

            <p>Slides for this talk: <a href="http://bit.ly/types-jfokus">
                http://bit.ly/types-jfokus
            </a></p>
            <p>Extended Version (constantly updated): <a href="http://bit.ly/js-types">
                http://bit.ly/js-types
            </a></p>
        </section>

    </div>

</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>
<script src="lib/jquery-2.2.4.js"></script>
<script>
//    $('section').attr('data-background-image', "backgrounds/dark-saddle.jpg")
//    $('section').attr('data-background-image', "backgrounds/dark-blue.jpg")
$('section').attr('data-background-image', "backgrounds/dark-sky.jpg")
//$('section').attr('data-background-image', "backgrounds/dark-case.jpg")
//$('section').attr('data-background-image', "backgrounds/dark-grid.jpg")
//    $('section').attr('data-background-image', "backgrounds/dark-fish.jpg")
</script>
<script>
    Reveal.addEventListener( 'ready', function( event ) {
        // only applies presentation version
        if (window.location.hostname.indexOf('localhost') !== -1) {
            Reveal.configure({ controls: false });
        } else {
            $('.fragment').removeClass('fragment');
        }
    } );
//    document.addEventListener("DOMContentLoaded", function () {
//        var elmElements = document.querySelectorAll(".elm");
//        var elmArray = Array.prototype.slice.call(elmElements);
//        elmArray.forEach(function (elm) {
//            elm.style.display = 'none';
//        });
//    });

</script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true},
            {src: 'lib/js/line-numbers.js'}
        ]
    });

</script>

</body>
</html>
