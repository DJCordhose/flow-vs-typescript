<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Type Systems for JavaScript</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">-->
    <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">-->


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
        .todo:before {
            content: 'TODO: ';
        }
        .todo {
            color: red !important;
        }
        code span.line-number {
            color: lightcoral;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h2>Typed JavaScript using TypeScript and Flow</h2>
            <p><a href="https://www.javaland.eu/konferenz/konferenzplaner/konferenzplaner_details.php?locS=0&id=522447&vid=529628" target="_blank">
                Javaland 2017,
            </a></p>

            <p>Slides for this talk: <a href="http://bit.ly/types-javaland">
                http://bit.ly/types-javaland
            </a></p>
            <p>
                <small><a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
                </small>
            </p>
            <p>Extended Version (constantly updated): <a href="http://bit.ly/js-types">
                http://bit.ly/js-types
            </a></p>
        </section>

        <section>
            <h2>Why using type systems?</h2>
            <div class="fragment">
                <h3>type systems make code easier to maintain</h3>
                <p >type annotations / inferred types</p>
                <ul >
                    <li>can make code more readable
                    <li>can make code easier to analyse
                    <li>can allow for reliable refactoring
                    <li>can allow for generally better IDE support
                    <li>can catch some (type related) errors early
                </ul>
            </div>
            <p class="fragment"><a href="https://channel9.msdn.com/Events/Build/2016/B881" target="_blank">
                Anders Hejlsberg@Build2016: <em>Big JavaScript codebases tend to become "read-only".</em>
            </a></p>
        </section>

        <section>
            <h3>weak to strong and dynamic to static</h3>
            <div style="height: 580px">
                <a href="https://twitter.com/DJCordhose/status/829242451294552066" target="_blank">
                    <img src="type-stragegies-twitter.png">
                </a>
            </div>
            <p><small>
                <a href="https://twitter.com/DJCordhose/status/829242451294552066" target="_blank">
                    https://twitter.com/DJCordhose/status/829242451294552066
                </a>
            </small></p>
        </section>

        <section>
            <h2>TypeScript</h2>
            <h3 class="fragment">ease of use and tool support over soundness</h3>
            <ul class="fragment">
                <li><a target="_blank" href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
                <li>By Microsoft (Anders Hejlsberg)
                <li>Based on ES6 (probably ES7/ES8)
                <li>Adds optional type annotations, visibility, and decorators
                <li>Compiler checks and removes annotations
                <li>2.x with major changes released recently
                <!--<li><a target="_blank" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript">Latest 1.8 release adds more general sane checks</a>-->
                <!--<li>External declarations can add type information to pure JavaScript-->
                <!--<li>Extensive support in-->

                <!--<a target="_blank" href="https://youtu.be/uceWBKISaF8">WebStorm</a> and Visual Studio Code-->
            </ul>
        </section>

        <section>
            <h2>Flow</h2>
            <h3 class="fragment">soundness, no runtime exceptions as goal</h3>
            <ul class="fragment">
                <li><a target="_blank" href="http://flowtype.org/">http://flowtype.org/</a>
                <li>By Facebook
                <li><em>Flow is a static type checker, designed to quickly find errors in JavaScript applications</em>
                <li>Not a compiler, but checker
                <!--<li>Works without any type annotations-->
                <!--<li>Very good at inferring types-->
                <li>If present, type annotations can very easily be removed by babel for runtime
            </ul>
        </section>

        <section>
            <h2>Demo</h2>
            <h3>Some basic TypeScript 2.2 hacking in Visual Studio Code 1.10</h3>
        </section>

        <section>
        <h3>TypeScript (similar to what we just hacked)</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>let foo: string;
// variables can have type information
let foo: string;
foo = 'yo';
// Error: Type 'number' is not assignable to type 'string'.
foo = 10;
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>

// types can be inferred (return type)
function sayIt(what: string) {
    return `Saying: ${what}`;
}
const said: string = sayIt(obj);

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
    what: string; // mandatory

    constructor(what: string) {
        this.what = what;
    }

    // return type if you want to
    sayIt(): string {
        return `Saying: ${this.what}`;
    }
}
</code></pre>
      </section>

        <section>
        <h3>Flow</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// variables can have type information
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// types can be explicit (parameter) or inferred (return type)
function sayIt(what: string) {
    return `Saying: ${what}`;
}
const said: string = sayIt(obj);

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
    what: string; // type also mandatory

    constructor(what: string) {
        this.what = what;
    }

    // return type if you want to
    sayIt(): string {
        return `Saying: ${this.what}`;
    }
}

</code></pre>
      </section>

        <section>
            <h2>Flow and TypeScript basics are pretty similar</h2>
            <p>Those basic features help with documentation, refactoring, and IDE support</p>
        </section>

        <section>
            <h2>Nullability</h2>
            <p>One of my main sources of runtime exceptions when programming Java</p>
            <p><small>Even after many years it is still surprising how many corner cases I miss in complex code</small></p>
        </section>

        <section class="flow">
            <h3>Flow</h3>
            <div class="fragment">
                <p>what is the result here in pure JavaScript?</p>
                <pre><code class="typescript line-numbers" contenteditable data-trim>
function foo(num) {
    if (num > 10) {
        return 'cool';
    }
}
console.log(foo(9).toString());
</code></pre>

            </div>
<pre class="fragment"><code class="javascript" contenteditable data-trim>
"Uncaught TypeError: Cannot read property 'toString' of undefined"
</code></pre>
            <div class="fragment">
                <p>What the flow checker thinks about this</p>
                <pre><code class="typescript line-numbers" contenteditable data-trim>
// error: call of method `toString`.
// Method cannot be called on possibly null value
console.log(foo(9).toString());
</code></pre>
            </div>
            <div class="fragment">
            <p>To fix this, we need to check the result</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
const fooed = foo(9);
if (fooed) {
    fooed.toString();
}
</code></pre>
            </div>
            <p class="fragment">Types are non-nullable by default in flow</p>
        </section>

        <section class="typescript">
            <h3>TypeScript</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// both TypeScript and flow allow
// to put the type annotation here instead of using inference
function foo(num: number) {
    if (num > 10) {
        return 'cool';
    }
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// same as flow
const fooed: string|void = foo(9);
if (fooed) {
    fooed.toString();
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// or tell the compiler we know better (in this case we actually do)
fooed!.toString();
</code></pre>
            <div class="fragment">
                <p>Only applies to TypeScript 2.x</p>
                <p>Only works when <em>strictNullChecks</em> option is checked</p>
                <p>All types nullable by default in TypeScript 1.x</p>
            </div>
        </section>

        <section>
            <h3>Generic Type information</h3>
            <p class="fragment">Types can be parameterized by others</p>
            <p class="fragment">Most common with collection types</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// nope, no cat
cats.push(10);
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="5">
// nope, no cat
cats.push(new Animal('Fido'));
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="7">
// cool, is a cat
cats.push(new Cat('Purry'));
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="9">
// cool, cat is a sub type of animal
animals.push(new Cat('Purry'));
           </code></pre>
        </section>

        <section>
            <h3>Up to this point this pretty much works in Flow and TypeScript the same way ...</h3>
        </section>

        <section>
            <h3>... but wait</h3>
        </section>

        <section>
        <h3>TypeScript</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// error TS2322: Type 'Animal[]' is not assignable to type 'Cat[]'.
//  Type 'Animal' is not assignable to type 'Cat'.
//    Property 'purrFactor' is missing in type 'Animal'.
cats = animals;
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="7">
// wow, works, but is no longer safe
animals = cats;
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim  data-num-start="9">
// because those are now all cool
animals.push(new Dog('Brutus'));
animals.push(new Animal('Twinky'));
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim  data-num-start="12">
// ouch:
cats.forEach(cat => console.log(`Cat: ${cat.name}`));
// Cat: Purry
// Cat: Brutus
// Cat: Twinky
</code></pre>
            <p class="fragment">TypeScript allows for birds and dogs to be cats here :)</p>
      </section>

        <section>
        <h3>Flow</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// ERROR
// property `purrFactor` of Cat. Property not found in Animal
cats = animals;
           </code></pre>
           <pre class="fragment"><code class="typescript  line-numbers" contenteditable data-trim data-num-start="6">
// same ERROR
animals = cats;
           </code></pre>
            <p class="fragment">Flow does not have have this caveat</p>
      </section>

        <section>
            <h2>The flipside</h2>
            <p>This code is safe (as we access cats in a readonly fashion)</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
function logAnimals(animals: Array&lt;Animal>) {
    animals.forEach(animal => console.log(`Animal: ${animal.name}`));
}

logAnimals(cats);
</code></pre>
            <ul  class="fragment">
                <li>This works in TypeScript (and it should)</li>
                <li>however, potentially not safe, there is nothing to keep us from writing to cats</li>
                <li>Flow does not allow this, even though it is safe</li>
            </ul>
            <div class="fragment">

            <p>much despised Java generics excel here as they can actually make that code safe (another difference:
                <a target="_blank" href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Comparing_declaration-site_and_use-site_annotations">
                    Use-site variance
                </a>)
            </p>
            <pre><code class="java line-numbers" contenteditable data-trim>
// Java
void logAnimals(List&lt;? extends Animal> animals) {
    animals.forEach(animal -> System.out.println("Animal: " + animal.name));
    // illegal:
    animals.add(new Animal("Twinky"));
}
</code></pre>
            </div>

        </section>

        <section>
            <h3>Some Type Inference Magic</h3>
            <p>Consider</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
class Dog { woof() { } }

const animals = [];
animals.push(new Dog());
</code></pre>
            <div class="fragment">
                <p>both TypeScript and Flow know this is safe, as we have only added Dogs so far</p>
                <pre><code class="typescript line-numbers" contenteditable data-trim data-num-start="5">
animals.forEach((animal: Dog) => animal.woof());
</code></pre>

            </div>
            <div class="fragment">
                <p>Adding Cats <em>later</em> and thus changing array type later</p>
                <pre><code class="typescript line-numbers" contenteditable data-trim>
class Cat { meow() { } }
animals.push(new Cat());
</code></pre>
                <p>does not affect TypeScript (correct), but makes Flow fail</p>

            </div>
        </section>

        <section>
            <h3>Differences in Generic Types</h3>
            <ul>
                <li class="fragment">TypeScript
                    <ul>
                        <li><a target="_blank" href="https://twitter.com/ahejlsberg/status/822882400724131841?s=03">always covariant</a> (more special):<br>
                            parametric types are compatible if the type to assign from has a more special type parameter</li>
                        <li>seems most intuitive, allows for obviously wrong code, though
                    </ul>
                </li>
                <li class="fragment">Flow
                    <ul>
                        <li>
                            <a href="https://flowtype.org/docs/classes.html#polymorphism-and-type-parameter-variance"
                            target="_blank">
                                using generic types you can choose from invariant (exact match), covariant <em>+</em> (more special), and contravariant <em>-</em> (more common)</a></li>
                        <li>Array in Flow has an invariant parametric type
                        <li>more expressive, harder to master, disallows some correct code
                    </ul>
                </li>
            </ul>
            <!--<p class="fragment">Both Flow and TypeScript support upper, but not lower bounds</p>-->
        </section>

        <section>
            <h3>`any` type</h3>
            <p class="fragment">can be anything, not specified</p>
            <p class="fragment">can selectively disable type checking</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function func(a: any) {
    return a + 5;
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// cool
let r1: string = func(10);

// cool
let r2: boolean = func('wat');
</code></pre>

            <ul>
                <li class="fragment"><em>flow / TypeScript 2</em>: explicit any supported, but any never inferred
            </ul>
        </section>

        <section>
            <h2>Union Types</h2>
            <p class="fragment">aka Disjoint Unions aka Tagged Unions aka Algebraic data types</p>
            <p class="fragment">to describe data with weird shapes</p>
            <p class="fragment">depending on some data other data might apply or not</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
 // a disjoint union type with two cases
type Response = Result | Failure;

type Result = { status: 'done', payload: Object }; // all good, we have the data
type Failure = { status: 'error', code: number}; // error, we get the error code
           </code></pre>
        </section>

        <section>
            <h3>Implementation both in Flow and TypeScript</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function callback(response: Response) {
    // works, as this is present in both
    console.log(response.status);
    // does not work,
    // as we do not know if it exists, just yet
    console.log(response.payload); // ERROR
    console.log(response.code); // ERROR
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-num-start="7">    switch (response.status) {
        case 'done':
            // this is the special thing:
            // type system now knows, this is a Result
            console.log(response.payload);
            break;
        case 'error':
            // and this is a Failure
            console.log(response.code);
            break;
    }
}           </code></pre>
        </section>

        <section>
            <h1>Are Flow and TypeScript like Java/C++/C#?</h1>
        </section>

        <section>
            <h2>Not really</h2>
            <ul>
                <li class="fragment">Both
                    <ul>
                        <li>optionally typed / any
                        <li>built to match common JavaScript programming patterns
                        <li>type systems more expressive
                        <li>type inference
                        <li>control flow based type analysis
                    </ul>
                </li>
                <li class="fragment">TypeScript
                    <ul>
                        <li>semantically compatible with JavaScript
                    </ul>
                </li>
                <li class="fragment">Flow
                    <ul>
                        <li>just a checker
                        <li>not even a language of its own
                        <li>non-nullability as default
                    </ul>
                </li>
            </ul>
        </section>

        <section>
            <h3>Nominal Typing for Flow classes</h3>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
class Person {
    name: string;
}

class Dog {
    name: string;
}

let dog: Dog = new Dog();

// nope, nominal type compatibility violated
let person: Person = dog; // ERROR: Dog: This type is incompatible with Person

// same problem
let person: Person = { // ERROR: object literal: This type is incompatible with Person
    name: "Olli"
};
            </code></pre>
        </section>

        <section>
            <h3>Structural Typing for TypeScript classes</h3>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
class Person {
    name: string;
}

class Dog {
    name: string;
}

let dog: Dog = new Dog();

// yes, correct, as structurally compatible
let person: Person = dog;

// same thing, also correct
let person: Person = {
    name: "Olli"
};

            </code></pre>
        </section>

        <section>
            <h2>Structural vs Nominal Typing</h2>
            <ul>
                <li class="fragment">Nominal Typing: types are compatible when their declared types match
                <li class="fragment">Structural Typing: types are compatible when their structures match
                <li class="fragment">Java, C#, C++, C all use nominal typing exclusively
                <li class="fragment">Flow classes are also treated as nominal types
                <li class="fragment">TypeScript classes are treated as structural types
                <li class="fragment">Everything else in both Flow and TypeScript uses structural typing
            </ul>
        </section>

        <section>
            <h3>Structural Typing for both TypeScript and Flow</h3>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
interface NamedObject {
    name: string;
}

// this is fine as nominal typing only applies to Flow classes
let namedObject: NamedObject = dog;

// same thing, also fine
let namedObject: NamedObject = {
    name: "Olli"
};

// not fine in either, missing name
let namedObject: NamedObject = {
    firstName: "Olli"
};
            </code></pre>
        </section>

        <section>
            <h2>Classes in TypeScript</h2>
            <p class="fragment">TypeScript has special support for classes</p>
            <p class="fragment">Similar features can be found in Java/C++/C#</p>
            <ul class="fragment">
                <li><em>abstract</em> classes and methods
                <li>special shortcut constructors (combined definition of fields and initialization)
                <li>public, private, protected
                <li>decorators (aka <a  target="_blank" href="https://msdn.microsoft.com/en-us/library/z0w1kczw(v=vs.80).aspx">
                Attributes in C#
                </a> and <a target="_blank" href="https://docs.oracle.com/javase/tutorial/java/annotations/">
Annotations in Java</a>)
                <li>
                    <a target="_blank"
                            href="https://blogs.msdn.microsoft.com/typescript/2016/09/22/announcing-typescript-2-0/">
                        readonly properties
            </a>
                 (TypeScript 2)
                <a target="_blank" href="https://msdn.microsoft.com/en-us/library/acdd6hb7.aspx">
                    like in C#
                </a>
            </ul>
            <p class="fragment">Flow does not feature those or any other syntactic sugar, as it is a checker only</p>
        </section>

        <section>
            <h2>Integration with raw JavaScript</h2>
        </section>

        <section>
            <h3>3rd Party Libraries in Flow</h3>
            <ul>
                <li>Core Declarations come with Flow Checker, includes React
                <li>Other external declarations are optional
                <li><a target="_blank"
                       href="https://github.com/flowtype/flow-typed">
                    External Flow Type Definitions
                </a>
                <li>some libraries even come with added flow type declarations (e.g. immutable.js)
                <li><a target="_blank"
                       href="https://flowtype.org/docs/third-party.html">
                    Declarations can be added to flow config files
                </a>
                <li>If there are no existing declaration files: still works, but less powerful
            </ul>
        </section>

        <section>
            <h3>TypeScript Declaration files</h3>
            <ul>
                <li>Much larger base for external declarations <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank">DefinitelyTyped</a>
                <li>TypeScript 1.x
                <ul>
                    <li>needed External Type Declarations for 3rd party libraries</li>
                    <li>turned out to be a major PITA</li>
                </ul>
                </li>
                <li>TypeScript 2.x
                    <ul>
                        <li>like Flow</li>
                        <li>install external type declarations transparently <a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/" target="_blank">using npm</a>
                            (e.g.<em>npm install @types/react --save</em>)
                    </ul>
                </li>
            </ul>
        </section>

        <section>
            <h2>IDE Support</h2>
        </section>

        <section>
            <h3>Visual Studio Code</h3>
            <ul>
                <li><a target="_blank" href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>
                <li>Excellent TypeScript support
                <li>Directly uses <a target="_blank" href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Language-Service-API">
                Language Service of TypeScript Compiler</a>
                <li>Written in TypeScript
            </ul>
        </section>

        <section>
            <h3>Atom / Nuclide</h3>
            <ul>
                <li><a target="_blank" href="https://atom.io/">https://atom.io/</a>
                <li><a target="_blank" href="https://nuclide.io/">https://nuclide.io/</a> (Atom Package)
                <li>Probably best Flow support
            </ul>
        </section>

        <section>
            <h3>IntelliJ IDEA / Webstorm</h3>
            <p>Starting from <em>2016.3</em></p>
                <ul>
                    <li><a target="_blank" href="https://blog.jetbrains.com/webstorm/2016/08/webstorm-2016-3-early-access-preview/#flow">
                        Flow: integrated checking and display of messages
                    </a>
                        <img src="screenshots/webstorm-flow.png" width="500px">
                    <li>Even better TypeScript support: uses <a target="_blank" href="https://blog.jetbrains.com/webstorm/2016/10/webstorm-2016-3-eap-163-6110/">
                    Language Service of TypeScript Compiler
                    </a>
                </ul>
        </section>

        <section>
            <h2>Where do they excel?</h2>
            <ul>
                <li class="fragment">TypeScript: <em>supporting people from Java and C# land</em>
                    <ul>
                        <li>more complete IDE support
                        <li>language server
                        <li>large set of 3rd party declaration files
                    </ul>
                </li>
                <li class="fragment">Flow: <em>providing typings for idiomatic JavaScript</em>
                    <ul>
                        <li>easy to get started even with existing project
                        <li>more powerful and flexible generics
                        <li>nominal typing for classes
                    </ul>
                </li>
            </ul>
        </section>

        <section>
            <h2>General observations / Trivia</h2>
            <ul>
                <li>If it is Angular it will be TypeScript
                <li>If people come from a JavaScript background and use React, they are more likely to choose flow
                <li>TypeScript has better tooling support
                <li>TypeScript 2.x has caught up with so many features previously only available in flow, so people are likely to choose TypeScript 2.x when they can start from scratch
            </ul>
        </section>
        <section>
            <h3>Special thanks for giving feedback and helping with this presentation</h3>
            <ul>
                <li>Daniel Rosenwasser: @drosenwasser (from the TypeScript team)</li>
                <li>Avik Chaudhuri: @__avik (from the Flow team)</li>
            </ul>
        </section>

        <section>
            <h1>Thank you!</h1>

            <h2>Questions / Discussion</h2>

            <p>
                <a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>

            </p>
            <p><a href="http://djcordhose.github.io/flow-vs-typescript/2017_javaland.html">
                http://djcordhose.github.io/flow-vs-typescript/2017_javaland.html
            </a></p>

        </section>

    </div>

</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>
<script src="lib/jquery-2.2.4.js"></script>
<script>
//    $('section').attr('data-background-image', "backgrounds/dark-saddle.jpg")
//    $('section').attr('data-background-image', "backgrounds/dark-blue.jpg")
$('section').attr('data-background-image', "backgrounds/dark-sky.jpg")
//$('section').attr('data-background-image', "backgrounds/dark-case.jpg")
//$('section').attr('data-background-image', "backgrounds/dark-grid.jpg")
//    $('section').attr('data-background-image', "backgrounds/dark-fish.jpg")
</script>
<script>
    Reveal.addEventListener( 'ready', function( event ) {
        // only applies presentation version
        if (window.location.hostname.indexOf('localhost') !== -1) {
            Reveal.configure({ controls: false });
        } else {
            $('.fragment').removeClass('fragment');
        }
    } );
//    document.addEventListener("DOMContentLoaded", function () {
//        var elmElements = document.querySelectorAll(".elm");
//        var elmArray = Array.prototype.slice.call(elmElements);
//        elmArray.forEach(function (elm) {
//            elm.style.display = 'none';
//        });
//    });

</script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true},
            {src: 'lib/js/line-numbers.js'}
        ]
    });

</script>

</body>
</html>
