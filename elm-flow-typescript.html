<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Type Systems for JavaScript</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">-->
    <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">-->


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
        .todo:before {
            content: 'TODO: ';
        }
        .todo {
            color: red !important;
        }
        code span.line-number {
            color: lightcoral;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

        <section>
            <h1>Type Systems for JavaScript</h1>
            <h2><span class="elm">Elm, </span>Flow, and TypeScript</h2>
            <p><small><a href="http://bit.ly/js-types">
                http://bit.ly/js-types
            </a></small></p>
            <p>
                <small><a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
                </small>
            </p>
        </section>

        <section>
            <h2>Why using type systems?</h2>
            <div class="fragment">
                <h3>type systems make code easier to maintain</h3>
                <p >type annotations</p>
                <ul >
                    <li>can make code more readable
                    <li>can make code easier to analyse
                    <li>can allow for reliable refactoring
                    <li>can allow for generally better IDE support
                    <li>can catch some (type related) errors early
                </ul>
            </div>
            <p class="fragment"><a href="https://channel9.msdn.com/Events/Build/2016/B881" target="_blank">
                Anders Hejlsberg@Build2016: <em>Big JavaScript codebases tend to become "read-only".</em>
            </a></p>
        </section>

        <section>
            <h2>http://stateofjs.com</h2>
            <p>Recently published survey on the state of JavaScript</p>
        </section>

        <section>
            <a href="http://stateofjs.com/2016/flavors/" target="_blank">
                <img src="overview-percent.png" height="600px">
            </a>
            <p><small><a href="http://stateofjs.com/2016/flavors/" target="_blank">
                http://stateofjs.com/2016/flavors/
            </a></small></p>
        </section>

        <section>
            <h2>TypeScript</h2>
            <h3 class="fragment">ease of use and tool support over soundness</h3>
            <ul class="fragment">
                <li><a target="_blank" href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
                <li>By Microsoft (Anders Hejlsberg)
                <li>Based on ES6 (probably ES7/ES8)
                <li>Adds optional type annotations, visibility, and decorators
                <li>Compiler checks and removes annotations
                <li>2.x with major changes released recently
                <!--<li><a target="_blank" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript">Latest 1.8 release adds more general sane checks</a>-->
                <!--<li>External declarations can add type information to pure JavaScript-->
                <!--<li>Extensive support in-->

                <!--<a target="_blank" href="https://youtu.be/uceWBKISaF8">WebStorm</a> and Visual Studio Code-->
            </ul>
        </section>

        <section>
            <h2>Flow</h2>
            <h3 class="fragment">soundness, no runtime exceptions as goal</h3>
            <ul class="fragment">
                <li><a target="_blank" href="http://flowtype.org/">http://flowtype.org/</a>
                <li>By Facebook
                <li><em>Flow is a static type checker, designed to quickly find errors in JavaScript applications</em>
                <li>Not a compiler, but checker
                <!--<li>Works without any type annotations-->
                <!--<li>Very good at inferring types-->
                <li>If present, type annotations can very easily be removed by babel for runtime
            </ul>
        </section>

        <section class="elm">
            <h2>Elm</h2>
            <h3 class="fragment">simplicity, soundness, no runtime exceptions</h3>
            <ul class="fragment">
                <li><a target="_blank" href="http://elm-lang.org/">http://elm-lang.org/</a>
                <li>Language of its own
                <li>functional, not object-oriented
                <li>no null, no mutation
                <li>Geared torwards Web Appliations
                <li>Compiler creates JavaScript
            </ul>
        </section>

        <section>
            <h2>Basics</h2>
        </section>

        <section>
        <h3>TypeScript</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>let foo: string;
foo = 'yo';
// Error: Type 'number' is not assignable to type 'string'.
foo = 10;
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>

// types can be inferred (return type)
function sayIt(what: string) {
    return `Saying: ${what}`;
}
const said: string = sayIt(obj);

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
    what: string; // mandatory

    constructor(what: string) {
        this.what = what;
    }

    // return type if you want to
    sayIt(): string {
        return `Saying: ${this.what}`;
    }
}
</code></pre>
      </section>

        <section>
        <h3>Flow</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function sayIt(what: string) {
    return `Saying: ${what}`;
}
const said: string = sayIt(obj);

</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
    what: string; // also mandatory

    constructor(what: string) {
        this.what = what;
    }

    sayIt(): string {
        return `Saying: ${this.what}`;
    }
}

</code></pre>
      </section>

        <section class="elm">
            <h3>Elm</h3>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
let
    foo : String
    foo = "yo"

    -- everthing is const, can not re-assign
    -- Error: `The definition of `obj2` does not match its type annotation.`
    foo2 : String
    foo2 = 10
</code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
-- type annotations are optional, can be inferred
sayIt : String -> String
sayIt what =
    "Saying: " ++ what

let
    said : String
    said = sayIt obj
</code></pre>
            <p class="fragment">No classes and methods in elm</p>
        </section>

        <section>
            <h2>Flow and TypeScript pretty similar</h2>
            <p>Those basic features help with documentation, refactoring, and IDE support</p>
        </section>

        <section>
            <h2>Nullability</h2>
        </section>

        <section class="elm">
            <h3>Elm</h3>
            <p class="fragment">There neither is <code>null</code> nor <code>undefined</code> in elm</p>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
foo : Int -> Maybe String
foo num =
    if num > 10 then
        Just "cool"
    else
        Nothing
</code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
text (
    case (foo 11) of
        Just message -> message
        Nothing -> ""
)
</code></pre>
            <p class="fragment">Rather <code>Maybe</code> plus pattern matching</p>
        </section>

        <section class="flow">
            <h3>Flow</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function foo(num: number) {
    if (num > 10) {
        return 'cool';
    }
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
console.log(foo(9).toString());
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// error: call of method `toString`.
// Method cannot be called on possibly null value
console.log(foo(9).toString());
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// to fix this, we need to check the result
const fooed: string|void = foo(9);
if (fooed) {
    fooed.toString();
}
</code></pre>
            <p class="fragment">Types are non-nullable by default in flow</p>
        </section>

        <section class="typescript">
            <h3>TypeScript</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function foo(num: number) {
    if (num > 10) {
        return 'cool';
    }
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// same as flow
const fooed: string|void = foo(9);
if (fooed) {
    fooed.toString();
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// or tell the compiler we know better (in this case we actually do)
fooed!.toString();
</code></pre>
            <p class="fragment">Only applies to TypeScript 2.x</p>
            <p class="fragment">Only works when <em>strictNullChecks</em> option is checked</p>
            <p class="fragment">All types nullable by default in TypeScript 1.x</p>
        </section>


        <section class="elm">
            <h3>Mutation, const</h3>
            <ul>
                <li class="fragment"><em>TypeScript and flow</em>: same as JavaScript (const optional, immutable via lib)
                <li class="fragment"><em>TypeScript</em>: readonly for properties
                <li class="fragment"><em>elm</em>: everything always immutable and const
            </ul>
        </section>

        <section>
            <h3>`any` type</h3>
            <p class="fragment">can be anything, not specified</p>
            <p class="fragment">can selectively disable type checking</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function func(a: any) {
    return a + 5;
}
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// cool
let r1: string = func(10);

// cool
let r2: boolean = func('wat');
</code></pre>

            <ul>
                <li class="fragment"><em>flow</em>: explicit any supported, but any never inferred
                <li class="fragment"><em>TypeScript</em>: explicit any supported
                <li class="fragment"><em>TypeScript 1.x</em>: any inferred if no type specified and no direct inference possible
                <li class="fragment"><em>TypeScript 2.x</em>: inference much smarter
                <li class="fragment elm"><em>elm</em>: does not exist, everything has exact type
            </ul>
        </section>

        <section class="elm">
            <h3>Type Compatibility</h3>
            <ul>
                <li class="fragment"><em>elm</em>: exact type match only
                <li class="fragment"><em>TypeScript and flow</em>: same as JavaScript (plus parametric types)
            </ul>
        </section>

        <section>
            <h3>Generic Type information</h3>
            <p class="fragment">Types can be parameterized by others</p>
            <p class="fragment">Most common with collection types</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// nope, no cat
cats.push(10);
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="5">
// nope, no cat
cats.push(new Animal('Fido'));
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="7">
// cool, is a cat
cats.push(new Cat('Purry'));
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="9">
// cool, cat is a sub type of animal
animals.push(new Cat('Purry'));
           </code></pre>
        </section>

        <section>
            <h3>Up to this point this pretty much works in Flow and TypeScript the same way ...</h3>
        </section>

        <section>
            <h3>... but wait</h3>
        </section>

        <section>
        <h3>TypeScript</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// error TS2322: Type 'Animal[]' is not assignable to type 'Cat[]'.
//  Type 'Animal' is not assignable to type 'Cat'.
//    Property 'purrFactor' is missing in type 'Animal'.
cats = animals;
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="7">
// wow, works, but is no longer safe
animals = cats;
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim  data-num-start="9">
// because those are now all cool
animals.push(new Dog('Brutus'));
animals.push(new Animal('Twinky'));
           </code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim  data-num-start="12">
// ouch:
cats.forEach(cat => console.log(`Cat: ${cat.name}`));
// Cat: Purry
// Cat: Brutus
// Cat: Twinky
</code></pre>
            <p class="fragment">TypeScript allows for birds and dogs to be cats here :)</p>
      </section>

        <section>
        <h3>Flow</h3>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let cats: Array&lt;Cat> = []; // can only contain cats
let animals: Array&lt;Animal> = []; // can only contain animals
</code></pre>
           <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim data-num-start="3">
// ERROR
// property `purrFactor` of Cat. Property not found in Animal
cats = animals;
           </code></pre>
           <pre class="fragment"><code class="typescript  line-numbers" contenteditable data-trim data-num-start="6">
// same ERROR
animals = cats;
           </code></pre>
            <p class="fragment">End of story for Flow</p>
      </section>

        <section>
            <h2>The flipside</h2>
            <p>This code is safe (as we access cats in a readonly fashion)</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
function logAnimals(animals: Array&lt;Animal>) {
    animals.forEach(animal => console.log(`Animal: ${animal.name}`));
}

logAnimals(cats);
</code></pre>
            <ul>
                <li class="fragment">This works in TypeScript (and it should)</li>
            <li class="fragment">however, potentially not safe, there is nothing from keeping us to still write to cats</li>
            <li class="fragment">Flow does not allow this, even though it is safe</li>
            </ul>
            <div class="fragment">

            <p>much despised Java generics excel here as they can actually make that code safe</p>
            <pre><code class="java line-numbers" contenteditable data-trim>
// Java
void logAnimals(List&lt;? extends Animal> animals) {
    animals.forEach(animal -> System.out.println("Animal: " + animal.name));
    // illegal:
    animals.add(new Animal("Twinky"));
}
</code></pre>
            </div>

        </section>

        <section class="elm">
            <h3>Elm</h3>
            <p class="fragment">Elm does not have classes or subtypes</p>
            <p class="fragment">Elm has Records (like JavaScript Objects) and generic data structures (e.g. List)</p>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
type alias Animal = { name : String }
type alias Cat = { name : String, coatColor : String }

cats : List Cat -- generic data structure
cats = [ someCat1, someCat2 ]

animals : List Animal
animals = [ someAnimal1, someAnimal2]
           </code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
-- sure
moreAnimals : List Animal
moreAnimals = animals

-- nope
-- Error: Looks like a record is missing the `coatColor` field.
catAnimals : List Animal
catAnimals = cats

-- nope, same problem
animalCats : List Cat
animalCats = animals
           </code></pre>
            <p class="fragment">Types always have to match exactly</p>
        </section>

        <section>
            <h3>Differences in Generic Types</h3>
            <ul>
                <li class="fragment">TypeScript
                    <ul>
                        <li>parametric types are compatible if the type to assign from has a more special type parameter</li>
                        <li>seems most intuitive, allows for obviously wrong code, though
                    </ul>
                </li>
                <li class="fragment">Flow
                    <ul>
                        <li>using generic types you can choose from invariant (exact match), covariant (more special), and contravariant (more common)</li>
                        <li>Array in Flow has an invariant parametric type
                        <li>more expressive, harder to master, disallows some correct code
                    </ul>
                </li>
                <li class="fragment elm">Elm
                    <ul>
                        <li>Generic data structures using type variables
                        <li>all types have to match exactly
                    </ul>
            </ul>
            <!--<p class="fragment">Both Flow and TypeScript support upper, but not lower bounds</p>-->
        </section>

        <section>
            <h3>Bounds in Generics</h3>
            <p>Both Flow and TypeScript support upper, not lower bounds</p>
            <p>Both Flow and TypeScript support
                <a target="_blank" href="https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification">
                    F-Bounded Polymorphism
                </a>
            </p>
            <p><a target="_blank" href="https://flowtype.org/blog/2015/03/12/Bounded-Polymorphism.html">https://flowtype.org/blog/2015/03/12/Bounded-Polymorphism.html</a></p>
            <p><a target="_blank" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#type-parameters-as-constraints">https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#type-parameters-as-constraints</a></p>
        </section>

        <section>
            <h3>Some Type Inference Magic</h3>
            <p>Works in both TypeScript and Flow</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
class Dog { woof() { } }

const animals = [];
animals.push(new Dog());

animals.forEach((animal: Dog) => animal.woof());
</code></pre>
            <p>both know this is safe, as we have only added Dogs so far</p>
            <div class="fragment">
            <p>Adding Cats later and thus changing array type later</p>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
class Cat { meow() { } }
animals.push(new Cat());
</code></pre>
                <p>does not affect TypeScript (correct), but makes Flow fail</p>

    </div>
        </section>

        <section>
            <h2>Union Types</h2>
            <p class="fragment">aka Disjoint Unions aka Tagged Unions aka Algebraic data types</p>
            <p class="fragment">to describe data with weird shapes</p>
            <p class="fragment">Depending on some data other data might apply or not</p>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
type Response = Result | Error; // a disjoint union type with two cases
type Result = { status: 'done', payload: Object };
type Error = { status: 'error', message: string };
           </code></pre>
        </section>

        <section>
            <h3>Implementation both in Flow and TypeScript</h3>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function callback(response: Response) {
    // given by code completion
    console.log(response.status);
    // does not work,
    // as we do not know if it exists, just yet
    console.log(result.payload); // ERROR
           </code></pre>
            <pre class="fragment"><code class="typescript line-numbers" contenteditable data-num-start="7">    switch (response.status) {
        case 'done':
            // this is the special thing:
            // type system now knows, this is a Response
            const result: Result = response;
            console.log(result.payload);
            break;
        case 'error':
            const error: Error = response;
            console.log(error.message);
            break;
    }
}           </code></pre>
        </section>

        <section class="elm">
            <h3>Elm</h3>
            <p class="fragment">simple and concise union types</p>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
type Resp = Res String | Err Int

callback : Resp -> String
callback response =
    -- pattern matching
    case response of
        Res payload -> payload
        Err code ->
                if code >= 400 && code < 500 then "you messed up" else "we messed up"
</code></pre>
            <pre class="fragment"><code class="elm line-numbers" contenteditable data-trim>
callback (Res "response")
-- response

callback (Err 404)
-- you messed up
            </code></pre>
            <p class="fragment">switching over union type alternatives using pattern matching</p>
        </section>

        <section>
            <h1>Are Flow and TypeScript like Java/C++/C#?</h1>
        </section>

        <section>
            <h2>Not really</h2>
            <ul>
                <li class="fragment">Both
                    <ul>
                        <li>optionally typed / any
                        <li>built to match common JavaScript programming patterns
                        <li>type systems more expressive
                        <li>type inference
                        <li>control flow based type analysis
                    </ul>
                </li>
                <li class="fragment">TypeScript
                    <ul>
                        <li>semantically compatible with JavaScript
                    </ul>
                </li>
                <li class="fragment">Flow
                    <ul>
                        <li>just a checker
                        <li>not even a language of its own
                        <li>non-nullability as default
                    </ul>
                </li>
            </ul>
        </section>

        <section>
            <h3>Nominal Typing for Flow classes</h3>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
class Person {
    name: string;
}

class Dog {
    name: string;
}

let dog: Dog = new Dog();

// nope, nominal type compatibility violated
let person: Person = dog; // ERROR: Dog: This type is incompatible with Person

// same problem
let person: Person = { // ERROR: object literal: This type is incompatible with Person
    name: "Olli"
};
            </code></pre>
        </section>

        <section>
            <h3>Structural Typing for TypeScript classes</h3>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
class Person {
    name: string;
}

class Dog {
    name: string;
}

let dog: Dog = new Dog();

// yes, correct, as structurally compatible
let person: Person = dog;

// same thing, also correct
let person: Person = {
    name: "Olli"
};

            </code></pre>
        </section>

        <section>
            <h2>Structural vs Nominal Typing</h2>
            <ul>
                <li class="fragment">Nominal Typing: types are compatible when their declared types match
                <li class="fragment">Structural Typing: types are compatible when their structures match
                <li class="fragment">Java, C#, C++, C all use nominal typing exclusively
                <li class="fragment">Flow classes are also treated as nominal types
                <li class="fragment">TypeScript classes are treated as structural types
                <li class="fragment">Everything else in both Flow and TypeScript uses structural typing
                <li class="elm">Elm always uses structural typing with exact matches on Records
            </ul>
        </section>

        <section>
            <h3>Structural Typing for both TypeScript and Flow</h3>
            <pre><code class="typescript line-numbers" contenteditable data-trim>
interface NamedObject {
    name: string;
}

// this is fine as nominal typing only applies to Flow classes
let namedObject: NamedObject = dog;

// same thing, also fine
let namedObject: NamedObject = {
    name: "Olli"
};

// not fine in either, missing name
let namedObject: NamedObject = {
    firstName: "Olli"
};
            </code></pre>
        </section>

        <section>
            <h2>Classes in TypeScript</h2>
            <p class="fragment">TypeScript has special support for classes</p>
            <p class="fragment">Makes it easier for people coming from Java/C++/C#</p>
            <ul class="fragment">
                <li><em>abstract</em> classes and methods
                <li>special shortcut constructors (combined definition of fields and initialization)
                <li>interfaces (that you can implement)
                <li>public, private, protected
                <li>decorators (aka <a  target="_blank" href="https://msdn.microsoft.com/en-us/library/z0w1kczw(v=vs.80).aspx">
                Attributes in C#
                </a> and <a target="_blank" href="https://docs.oracle.com/javase/tutorial/java/annotations/">
Annotations in Java</a>)
                <li>
                    <a target="_blank"
                            href="https://blogs.msdn.microsoft.com/typescript/2016/09/22/announcing-typescript-2-0/">
                        readonly properties
            </a>
                 (TypeScript 2)
                <a target="_blank" href="https://msdn.microsoft.com/en-us/library/acdd6hb7.aspx">
                    like in C#
                </a>
            </ul>
            <p class="fragment">Flow does not feature those or any other syntactic sugar, as it is a checker only</p>
        </section>

        <section>
            <h2>Integrations of raw JavaScript files</h2>
        </section>

        <section>
            <h3>3rd Party Libraries in Flow</h3>
            <ul>
                <li>Core Declarations come with Flow Checker, includes React
                <li>Other external declarations are optional
                <li><a target="_blank"
                       href="https://github.com/flowtype/flow-typed">
                    External Flow Type Definitions
                </a>
                <li>some libraries even come with added flow type declarations (e.g. immutable.js)
                <li><a target="_blank"
                       href="https://flowtype.org/docs/third-party.html">
                    Declarations can be added to flow config files
                </a>
                <li>If there are no existing declaration files: still works, but less powerful
            </ul>
        </section>

        <section>
            <h3>TypeScript Declaration files</h3>
            <ul>
                <li>Much larger base for external declarations <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank">DefinitelyTyped</a>
                <li>TypeScript 1.x
                <ul>
                    <li>needed External Type Declarations for 3rd party libraries</li>
                    <li>turned out to be a major PITA</li>
                </ul>
                </li>
                <li>TypeScript 2.x
                    <ul>
                        <li>like Flow</li>
                        <li>install external type declarations transparently <a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/" target="_blank">using npm</a>
                            (e.g.<em>npm install @types/react --save</em>)
                    </ul>
                </li>
            </ul>
        </section>

        <section class="elm">
            <h3>Using JavaScript Code in Elm</h3>
            <ul>
                <li>in practice, most production Elm projects end up wanting to access the JS ecosystem
                <li>integration works via messages through ports (<a target="_blank"
                       href="https://guide.elm-lang.org/interop/javascript.html">
                https://guide.elm-lang.org/interop/javascript.html
                </a>)
                <li>Only part of the app where there can still be runtime exceptions
                <li>data from JavaScript sent like JSON
                <li>needs to be converted and typed in Elm
            </ul>
        </section>

        <section>
            <h2>IDE Support</h2>
        </section>

        <section>
            <h3>Visual Studio Code</h3>
            <ul>
                <li><a target="_blank" href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>
                <li>Excellent TypeScript support
                <li>Directly uses <a target="_blank" href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Language-Service-API">
                Language Service of TypeScript Compiler</a>
                <li>Written in TypeScript
                <li class="elm">Basic Elm support via Plugin
            </ul>
        </section>

        <section>
            <h3>Atom / Nuclide</h3>
            <ul>
                <li><a target="_blank" href="https://atom.io/">https://atom.io/</a>
                <li><a target="_blank" href="https://nuclide.io/">https://nuclide.io/</a> (Atom Package)
                <li>Probably best Flow support
            </ul>
        </section>

        <section>
            <h3>IntelliJ IDEA / Webstorm</h3>
            <p>Starting from <em>2016.3</em></p>
                <ul>
                    <li><a target="_blank" href="https://blog.jetbrains.com/webstorm/2016/08/webstorm-2016-3-early-access-preview/#flow">
                        Flow: integrated checking and display of messages
                    </a>
                        <img src="screenshots/webstorm-flow.png" width="500px">
                    <li>Even better TypeScript support: uses <a target="_blank" href="https://blog.jetbrains.com/webstorm/2016/10/webstorm-2016-3-eap-163-6110/">
                    Language Service of TypeScript Compiler
                    </a>
                    <li>Basic Elm support via Plugin
                </ul>
        </section>

        <section>
            <h3 style="top: -30px; position: relative">Should you use a type checker?</h3>
            <ul class="fragment" style="top: -30px; position: relative">
                <li>don't be fooled: checkers do not make your programs error free
                <li><a target="_blank" href="http://danluu.com/empirical-pl/">there seems to be little or no impact on productivity</a>
                <li>initial effort to introduce a checker is low, though
                <li>but a type system is a complex thing, it comes at a cost
            </ul>
            <p class="fragment" style="top: -30px; position: relative">My biased recommendation</p>
            <ul class="fragment" style="top: -40px; position: relative">
                <li >your project does not live for long: <em >no</em>
                <li >your project is really simple: <em >no</em>
                <li >there is a chance you will need to refactor the thing: <em >yes</em>
                <li >your system is very important or even crucial for the success of your company: <em >yes</em>
                <li >people enter or leave your team frequently: <em >yes</em>
                <li >you have substantial amount of algorithmic code: <em >yes</em>
            </ul>
        </section>

        <section>
            <h2>Where do they excel?</h2>
            <ul>
                <li class="fragment">TypeScript: <em>supporting people from Java and C# land</em>
                    <ul>
                        <li>more complete IDE support
                        <li>language server
                        <li>large set of 3rd party declaration files
                    </ul>
                </li>
                <li class="fragment">Flow: <em>proving types for idiomatic JavaScript</em>
                    <ul>
                        <li>easy to get started even with existing project
                        <li>more powerful and flexible generics
                        <li>nominal typing for classes
                    </ul>
                </li>
                <li class="fragment elm">Elm: <em>functional language deliberately different from JavaScript</em>
                    <ul>
                        <li>simplicity of type system (no JavaScript legacy)
                        <li>always completely typed (no any)
                        <li>everything immutable and constant always and everywhere
                        <li>complete package (also great orientation for beginners)
                    </ul>
                </li>
            </ul>
        </section>

        <section>
            <h3>Special thanks for giving feedback and helping with this presentation</h3>
            <ul>
                <li>Daniel Rosenwasser: @drosenwasser (from the TypeScript team)</li>
                <li>Avik Chaudhuri: @__avik (from the Flow team)</li>
                <li>Richard Feldman: @rtfeldman and Evan Czaplicki: @czaplic (Elm people)</li>
            </ul>
        </section>

        <section>
            <h1>Thank you!</h1>

            <h2>Questions / Discussion</h2>

            <p>
                <a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>

            </p>
            <p><a href="http://djcordhose.github.io/flow-vs-typescript/elm-flow-typescript.html">
                http://djcordhose.github.io/flow-vs-typescript/elm-flow-typescript.html
            </a></p>

        </section>

                <!--<section>-->
            <!--<h3>Resources</h3>-->
            <!--<ul>-->
                <!--<li><a target="_blank"-->
                       <!--href="https://javascriptair.com/episodes/2016-08-31/">-->
                    <!--JavaScript Air | Typed JavaScript with TypeScript and Flow-->
                <!--</a>-->
                <!--<li><a target="_blank"-->
                       <!--href="http://blog.namangoel.com/flow-for-typescript-developers">-->
                    <!--Flow for TypeScript Developers-->
                <!--</a>-->

            <!--<li>Flow-->
                <!--<ul>-->
                    <!--<li><a target="_blank"-->
                           <!--href="https://medium.com/@thejameskyle/flow-mapping-an-object-373d64c44592#.5fhfyngkf">-->
                        <!--Flow: Mapping an object-->
                    <!--</a>-->
                <!--<li><a target="_blank"-->
                       <!--href="https://www.jetbrains.com/help/webstorm/2016.1/using-the-flow-type-checker.html">-->
                    <!--Flow in WebStorm-->
                <!--</a>-->
                    <!--<li><a target="_blank"-->
                           <!--href="https://www.flowtype.org/blog/2016/08/01/Windows-Support.html">-->
                        <!--Official Windows binaries since August 2016-->
                    <!--</a>-->
                    <!--<li><a target="_blank"-->
                           <!--href="https://medium.com/@ikai/james-thanks-for-writing-this-795437144d08#.mbd4fyq3l">-->
                        <!--Medium uses Flow-->
                    <!--</a>-->
                    <!--<li><a target="_blank"-->
                           <!--href="http://www.robinwieruch.de/the-soundcloud-client-in-react-redux-flow/">-->
                    <!--Type Checking with Flow in React + Redux-->
                    <!--</a>-->
                    <!--<li><a target="_blank"-->
                           <!--href="https://github.com/flowtype/flow-typed">-->
                        <!--External Type Definitions-->
                    <!--</a>-->
            <!--</ul>-->
            <!--</li>-->
                <!--<li>TypeScript-->
                    <!--<ul>-->
                        <!--<li><a target="_blank"-->
                               <!--href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript">-->
                            <!--What's new in TypeScript-->
                        <!--</a>-->
                        <!--<li><a target="_blank"-->
                               <!--href="https://github.com/Microsoft/TypeScript/wiki/Roadmap">-->
                        <!--Roadmap-->
                        <!--</a>-->
                        <!--<li><a target="_blank"-->
                               <!--href="https://channel9.msdn.com/Blogs/Seth-Juarez/Anders-Hejlsberg-on-Modern-Compiler-Construction">-->
                        <!--Anders Hejlsberg on Modern Compiler Construction-->
                        <!--</a>-->
                        <!--<li><a target="_blank"-->
                               <!--href="https://channel9.msdn.com/Blogs/Seth-Juarez/Anders-Hejlsberg-on-TypeScript-2">-->
                        <!--Anders Hejlsberg on TypeScript 2-->
                        <!--</a>-->
                        <!--<li><a target="_blank"-->
                               <!--href="https://vsavkin.com/functional-typescript-316f0e003dc6#.7pooz4sba">-->
                        <!--Functional TypeScript-->
                        <!--</a>-->

                    <!--</ul>-->
                <!--</li>-->
            <!--</ul>-->
        <!--</section>-->


    </div>

</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>
<script src="lib/jquery-2.2.4.js"></script>
<script>
//    $('section').attr('data-background-image', "backgrounds/dark-saddle.jpg")
//    $('section').attr('data-background-image', "backgrounds/dark-blue.jpg")
$('section').attr('data-background-image', "backgrounds/dark-sky.jpg")
//$('section').attr('data-background-image', "backgrounds/dark-case.jpg")
//$('section').attr('data-background-image', "backgrounds/dark-grid.jpg")
//    $('section').attr('data-background-image', "backgrounds/dark-fish.jpg")
</script>
<script>
    Reveal.addEventListener( 'ready', function( event ) {
        // only applies presentation version
        if (window.location.hostname.indexOf('localhost') !== -1) {
            Reveal.configure({ controls: false });
        } else {
            $('.fragment').removeClass('fragment');
        }
    } );
//    document.addEventListener("DOMContentLoaded", function () {
//        var elmElements = document.querySelectorAll(".elm");
//        var elmArray = Array.prototype.slice.call(elmElements);
//        elmArray.forEach(function (elm) {
//            elm.style.display = 'none';
//        });
//    });

</script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true},
            {src: 'lib/js/line-numbers.js'}
        ]
    });

</script>

</body>
</html>
